ABOUT
=====

# 数据库设计

## 命名规范

* 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint ( 1表示是，0表示否),正例:表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。
* 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只 出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑 
* 表名不使用复数名词,说明:表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数 形式，符合表达习惯 
* 禁用保留字
* 主键索引名为 pk_字段名;唯一索引名为 uk_字段名;普通索引名则为 idx_字段名
* 小数类型为 decimal，禁止使用 float 和 double
* 如果存储的字符串长度几乎相等，使用 char 定长字符串类型
* varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长 度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率
* 表必备三字段:id, is_delete,gmt_create, gmt_modified。 说明:其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被 动更新。
* 所有命名必须使用全名，有默认约定的除外，如果超过 30 个字符，使用缩写，请尽量名字易懂简短，如 description --> desc;information --> info;address --> addr 等
* 表的命名最好是加上“业务名称_表的作用”。 正例:health_user / trade_config
* 库名与应用名称尽量一致。如health 
* 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释
* 所有时间字段，都以 gmt_开始，后面加上动词的过去式，最后不要加上 time 单词，例如 gmt_create


## 设计规范

* 字段允许适当冗余,但必须考虑数据一致,冗余字段应遵循:
  * 不是频繁修改的字段
  * 不是varchar超长字段
  * 绝不可以是text字段
* 单表行数超500万行或单表容量超过2G，才推荐进行分库分表:如果预计2年后无法达到此数据量，不要在创建表时就分库、分表；
* id必须是主键，且每张表必须有主键,保持增长趋势的小型系统可以依赖于数据库自增主键，大型系统或者需要分库分表时才使用内置的ID生成器
* ID类型没有特殊要求,必须使用bigint unsigned，禁止使用int,如果是数字类型的话，必须是8个字节;
* 字段尽量设置为 NOT NULL,并为字段提供默认值,如字符型的默认值为一个空字符值串’’;数值型默认值为数值 0;逻辑型的默认值为数值 0;
* 每个字段和表必须提供清晰的注释
* 时间统一格式:‘YYYY-MM-DD HH:MM:SS’
* 更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间,

## 类型规范

* 表示状态字段(0-255)的使用 TINYINT UNSINGED，禁止使用枚举 类型，注释必须清晰地说明每个枚举的含义，以及是否多选等
* 表示boolean类型的都使用TINYINT(1),因为mysql本身是没有boolean类型的，在自动生成代码的时候，DO对象的字段就是boolean类型，例如 is_delete;其余所有时候都使用TINYINT(4)
* 合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度
* 非负的数字类型字段，都添加上 UNSINGED, 如可以使用 INT UNSINGED 字段存 IPV4
* 时间字段使用时间日期类型，不要使用字符串类型存储，日期使用DATE类型，年使用YEAR类型，日期时间使用DATETIME
* 字符串VARCHAR(N), 其中 N表示字符个数，请尽量减少 N 的大小，参考：code VARCHAR(32)；name VARCHAR(32)；memo VARCHAR(512)；
* Blob 和 Text 类型所存储的数据量大，删除和修改操作容易在数 据表里产生大量的碎片，避免使用 Blob 或 Text 类型

## 索引规范

* 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
* 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致;多表关联查询时， 保证被关联的字段需要有索引。
* 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。
* 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决
* 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能
* 利用覆盖索引来进行查询操作，避免回表。
* 利用延迟关联或者子查询优化超多分页场景
* SQL 性能优化的目标:至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好
* 创建索引时避免有如下极端误解
  * 宁滥勿缺。认为一个查询就需要建一个索引
  * 宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。
  * 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。
* 索引占磁盘空间，不要重复的索引，尽量短 
  * 只给常用的查询条件加索引  
  * 过滤性高的列建索引，取值范围固定的列不建索引
  * 唯一的记录添加唯一索引
  * 频繁更新的列不要建索引
  * 不要对索引列运算
  * 同样过滤效果下，保持索引长度最小
  * 合理利用组合索引，注意索引字段先后顺序
  * 多列组合索引，过滤性高的字段最前  
  * order by 字段建立索引，避免 filesort 
  * 组合索引，不同的排序顺序不能使用索引

## SQL规范

* 不要使用 count(列名)或 count(常量)来替代 count()， 
* count(distinct col) 计算该列除 NULL 之外的不重复行数
* 当某一列col的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题
* 使用 ISNULL()来判断是否为 NULL 值。 说明:NULL 与任何值的直接比较都为 NULL
* 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句
* 不得使用外键与级联，一切外键概念必须在应用层解决
* 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性
* 数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句
* in操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内
* 如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别

# 关于仓库物品编码

概念

根据商品管理管理和运营方式有如下概念

* SKU:（Stock Keeping Unit）
* SPU:（Single Product Unit）

6587e8acc0efa08b239fa7b1
